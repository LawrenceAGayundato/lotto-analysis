<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCSO Lottery Statistical Analysis & Prediction System</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(255, 255, 255, 0.1);
            overflow: hidden;
            border: 1px solid #e0e0e0;
        }

        header {
            background: #000000;
            color: white;
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #333333;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls label {
            font-weight: 600;
            color: #495057;
        }

        .controls select, .controls input {
            padding: 10px 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .controls select:hover, .controls input:hover {
            border-color: #000000;
        }

        .controls button {
            padding: 10px 25px;
            background: #000000;
            color: white;
            border: 1px solid #333333;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            background: #333333;
        }

        .icon-btn {
            width: 45px;
            height: 45px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            position: relative;
            cursor: pointer;
        }

        .icon-btn:hover {
            transform: rotate(180deg);
            transition: transform 0.5s ease;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: #333333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85em;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333333 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8f9fa;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        .stat-card h3 {
            color: #000000;
            font-size: 2em;
            margin-bottom: 5px;
        }

        .stat-card p {
            color: #6c757d;
            font-size: 0.9em;
        }

        .content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            padding: 12px 25px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #6c757d;
            transition: all 0.3s;
        }

        .tab.active {
            color: #000000;
            border-bottom-color: #000000;
        }

        .tab:hover {
            color: #000000;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-top: 20px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }

        .results-table th {
            background: #000000;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .results-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e9ecef;
        }

        .results-table tr:hover {
            background: #f8f9fa;
        }

        .lotto-numbers {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .lotto-ball {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #000000;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1em;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 1px solid #333333;
        }

        .frequency-chart {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .frequency-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            transition: all 0.3s;
        }

        .frequency-item:hover {
            background: #000000;
            color: white;
            border-color: #000000;
            transform: scale(1.05);
        }

        .frequency-item .number {
            font-size: 1.5em;
            font-weight: bold;
            color: #000000;
        }

        .frequency-item:hover .number {
            color: white;
        }

        .frequency-item .count {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .frequency-item:hover .count {
            color: white;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #6c757d;
            font-size: 1.2em;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .info {
            background: #d1ecf1;
            color: #0c5460;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #bee5eb;
        }

        .chart-container {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .chart-wrapper {
            position: relative;
            height: auto;
            min-height: 500px;
            margin: 20px 0;
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .chart-wrapper canvas {
            max-height: 350px;
            height: 350px !important;
            width: 100% !important;
        }

        .chart-canvas-container {
            position: relative;
            height: 350px;
            margin-bottom: 10px;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-top: 20px;
        }

        .chart-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #000000;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .chart-insight {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-left: 4px solid #000000;
            border-radius: 5px;
            font-size: 0.9em;
            color: #495057;
            line-height: 1.6;
        }

        .no-data {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }

        .prediction-section {
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            border-left: 4px solid #000000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .prediction-section h3 {
            color: #000000;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .prediction-numbers {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin: 20px 0;
            justify-content: center;
        }

        .prediction-ball {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #000000;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.3em;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.5s ease-in;
            border: 1px solid #333333;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .model-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
            color: #495057;
        }

        .model-info strong {
            color: #000000;
        }

        .confidence-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: #000000;
            transition: width 0.5s ease;
        }

        .generate-btn {
            padding: 12px 30px;
            background: #000000;
            color: white;
            border: 1px solid #333333;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px 5px;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            background: #333333;
        }

        .generate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .model-selector {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .model-selector label {
            font-weight: 600;
            color: #495057;
            margin-right: 10px;
        }

        .model-selector select {
            padding: 10px 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 20px;
        }

        .pagination button {
            padding: 8px 16px;
            background: #000000;
            color: white;
            border: 1px solid #333333;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .pagination button:hover:not(:disabled) {
            background: #333333;
            transform: translateY(-2px);
        }

        .pagination button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .pagination .page-info {
            padding: 8px 16px;
            color: #495057;
            font-weight: 600;
        }

        .pagination select {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            background: white;
            font-weight: 600;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                border-radius: 10px;
            }

            header h1 {
                font-size: 1.8em;
            }

            header p {
                font-size: 0.9em;
            }

            .stats-grid {
                grid-template-columns: 1fr;
                padding: 15px;
                gap: 10px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
                padding: 15px;
                gap: 10px;
            }

            .controls select,
            .controls input,
            .controls button {
                width: 100%;
                font-size: 0.95em;
            }

            .icon-btn {
                width: 100%;
                height: 45px;
            }

            .tooltip {
                width: 100%;
            }

            .tabs {
                flex-direction: column;
                padding: 0 10px;
            }

            .tab {
                width: 100%;
                text-align: center;
            }

            .tab-content {
                padding: 15px;
            }

            .prediction-ball {
                width: 40px;
                height: 40px;
                font-size: 1.1em;
            }

            .prediction-numbers {
                gap: 8px;
            }

            .model-info {
                font-size: 0.85em;
            }

            .chart-wrapper {
                min-height: 450px;
                padding: 20px;
                margin: 15px 0;
            }

            .chart-wrapper canvas {
                max-height: 280px;
                height: 280px !important;
            }

            .chart-canvas-container {
                height: 280px;
            }

            .charts-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .chart-title {
                font-size: 1em;
            }

            .chart-insight {
                font-size: 0.85em;
            }

            .chart-title {
                font-size: 1em;
            }

            .table-wrapper {
                margin: 10px -15px;
                width: calc(100% + 30px);
            }

            .results-table {
                min-width: 100%;
                font-size: 0.8em;
            }

            .results-table th {
                padding: 10px 8px;
                font-size: 0.85em;
                position: sticky;
                top: 0;
                z-index: 10;
            }

            .results-table td {
                padding: 10px 8px;
                font-size: 0.85em;
            }

            .lotto-ball {
                width: 32px;
                height: 32px;
                font-size: 0.9em;
            }

            .lotto-numbers {
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>PCSO Lottery Statistical Analysis & Prediction System</h1>
            <p>A Data-Driven Approach to Lottery Pattern Analysis & Forecasting</p>
        </header>

        <div class="info" style="margin-bottom: 20px;">
            <p><strong>Note:</strong>This is an experimental project developed independently, presenting predictions and analyses based on statistical patterns and machine learning models for educational and research purposes only. Even if applied, lottery results cannot be accurately predicted because they are purely random and have no relation to past events.</p>
        </div>

        <div class="controls">
            <label for="gameFilter">Game:</label>
            <select id="gameFilter">
                <option value="all">All Games</option>
                <option value="6/58">Ultra Lotto 6/58</option>
                <option value="6/55">Grand Lotto 6/55</option>
                <option value="6/49">Super Lotto 6/49</option>
                <option value="6/45">Mega Lotto 6/45</option>
                <option value="6/42">Lotto 6/42</option>
                <option value="4D">4D Lotto</option>
                <option value="3D">3D Lotto</option>
                <option value="2D">2D Lotto</option>
            </select>

            <label for="dateFrom">From:</label>
            <input type="date" id="dateFrom">

            <label for="dateTo">To:</label>
            <input type="date" id="dateTo">

            <button onclick="filterToday()">Today's Draw</button>
            <button onclick="filterYesterday()">Yesterday's Draw</button>
            <button onclick="applyFilters()">Apply Filters</button>
            <div class="tooltip">
                <button class="icon-btn" onclick="loadData()">↻</button>
                <span class="tooltiptext">Refresh Data</span>
            </div>
        </div>

        <div class="stats-grid" id="statsGrid">
            <!-- Stats will be populated here -->
        </div>

        <div class="content">
            <div class="tabs">
                <button class="tab active" onclick="switchTab(event, 'recent')">Recent Results</button>
                <button class="tab" onclick="switchTab(event, 'frequency')">Number Frequency</button>
                <button class="tab" onclick="switchTab(event, 'analysis')">Analysis</button>
                <button class="tab" onclick="switchTab(event, 'prediction')">AI Prediction</button>
            </div>

            <div id="recent" class="tab-content active">
                <div id="recentResults">
                    <div class="loading">Loading results...</div>
                </div>
            </div>

            <div id="frequency" class="tab-content">
                <div id="frequencyAnalysis">
                    <div class="loading">Loading frequency analysis...</div>
                </div>
            </div>

            <div id="analysis" class="tab-content">
                <div id="detailedAnalysis">
                    <div class="loading">Loading analysis...</div>
                </div>
            </div>

            <div id="prediction" class="tab-content">
                <div id="predictionAnalysis">
                    <div class="loading">Loading prediction models...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Cache buster: v2.0 - Fixed template literals
        let allData = null;
        let filteredData = null;
        let statistics = null;
        
        // Pagination variables
        let currentPage = 1;
        let itemsPerPage = 15;

        // Load data on page load
        window.onload = function() {
            loadData();
        };

        async function loadData() {
            try {
                // Show loading message
                document.getElementById('recentResults').innerHTML = 
                    '<div class="loading">Loading PCSO data...</div>';
                
                // Only call API if running locally (not on GitHub Pages)
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    try {
                        const updateResponse = await fetch('http://localhost:5000/api/update-data', {
                            method: 'POST'
                        });
                        
                        if (updateResponse.ok) {
                            console.log('Data updated successfully');
                        }
                    } catch (apiError) {
                        console.warn('API server not available, using static data');
                    }
                }
                
                // Load main data
                const response = await fetch('pcso_lotto_data.json?t=' + Date.now());
                if (!response.ok) {
                    throw new Error('Data file not found.');
                }
                allData = await response.json();
                
                // Load statistics
                const statsResponse = await fetch('pcso_statistics.json?t=' + Date.now());
                if (statsResponse.ok) {
                    statistics = await statsResponse.json();
                }

                filteredData = allData.results;
                
                // Initialize date pickers with min and max dates from data
                initializeDatePickers();
                
                updateDisplay();
            } catch (error) {
                document.getElementById('recentResults').innerHTML = 
                    '<div class="error">' +
                        '<strong>Error loading data:</strong> ' + error.message +
                        '<br><br>' +
                        'Data is being updated automatically via GitHub Actions every 6 hours.' +
                    '</div>';
            }
        }

        function initializeDatePickers() {
            if (!allData || !allData.results || allData.results.length === 0) return;

            // Get min and max dates from data
            const dates = allData.results.map(d => d.date);
            const minDate = dates.reduce((a, b) => a < b ? a : b);
            const maxDate = dates.reduce((a, b) => a > b ? a : b);

            // Set the date input values and attributes
            const dateFromInput = document.getElementById('dateFrom');
            const dateToInput = document.getElementById('dateTo');

            dateFromInput.value = minDate;
            dateFromInput.min = minDate;
            dateFromInput.max = maxDate;

            dateToInput.value = maxDate;
            dateToInput.min = minDate;
            dateToInput.max = maxDate;
        }

        function applyFilters() {
            if (!allData) return;

            let data = [...allData.results];
            const gameFilter = document.getElementById('gameFilter').value;
            const dateFrom = document.getElementById('dateFrom').value;
            const dateTo = document.getElementById('dateTo').value;

            // Filter by game
            if (gameFilter !== 'all') {
                data = data.filter(item => item.game_type === gameFilter);
            }

            // Filter by date range
            if (dateFrom) {
                data = data.filter(item => item.date >= dateFrom);
            }
            if (dateTo) {
                data = data.filter(item => item.date <= dateTo);
            }

            filteredData = data;
            currentPage = 1; // Reset to first page when filtering
            updateDisplay();
        }

        function filterToday() {
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            
            document.getElementById('dateFrom').value = todayStr;
            document.getElementById('dateTo').value = todayStr;
            
            applyFilters();
        }

        function filterYesterday() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toISOString().split('T')[0];
            
            document.getElementById('dateFrom').value = yesterdayStr;
            document.getElementById('dateTo').value = yesterdayStr;
            
            applyFilters();
        }

        function updateDisplay() {
            updateDateRangeDisplay();
            updateStats();
            updateRecentResults();
            updateFrequencyAnalysis();
            updateDetailedAnalysis();
            updatePredictionAnalysis();
        }

        function updateDateRangeDisplay() {
            if (!filteredData || filteredData.length === 0) {
                document.getElementById('dateRangeDisplay').innerHTML = '';
                return;
            }

            // Get min and max dates from filtered data
            const dates = filteredData.map(d => new Date(d.date));
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            // Format dates
            const formatDate = (date) => {
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return months[date.getMonth()] + ' ' + date.getDate() + ', ' + date.getFullYear();
            };

            const dateRangeText = 'Displaying data from ' + formatDate(minDate) + ' to ' + formatDate(maxDate) + 
                                  ' (' + filteredData.length + ' draws)';
            
            document.getElementById('dateRangeDisplay').innerHTML = dateRangeText;
        }

        function updateStats() {
            if (!filteredData) return;

            const games = {};
            let totalJackpot = 0;
            let totalWinners = 0;

            filteredData.forEach(result => {
                if (!games[result.game_type]) {
                    games[result.game_type] = 0;
                }
                games[result.game_type]++;
                totalJackpot += result.jackpot || 0;
                totalWinners += result.winners || 0;
            });

            const statsHTML = 
                '<div class="stat-card">' +
                    '<h3>' + filteredData.length + '</h3>' +
                    '<p>Total Draws</p>' +
                '</div>' +
                '<div class="stat-card">' +
                    '<h3>' + Object.keys(games).length + '</h3>' +
                    '<p>Games</p>' +
                '</div>' +
                '<div class="stat-card">' +
                    '<h3>₱' + (totalJackpot / 1000000).toFixed(1) + 'M</h3>' +
                    '<p>Total Jackpots</p>' +
                '</div>' +
                '<div class="stat-card">' +
                    '<h3>' + totalWinners + '</h3>' +
                    '<p>Total Winners</p>' +
                '</div>';

            document.getElementById('statsGrid').innerHTML = statsHTML;
        }

        function updateRecentResults() {
            if (!filteredData || filteredData.length === 0) {
                document.getElementById('recentResults').innerHTML = 
                    '<div class="no-data">No results found for the selected filters.</div>';
                return;
            }

            // Sort by date (most recent first)
            const sortedData = [...filteredData].sort((a, b) => 
                new Date(b.date) - new Date(a.date)
            );

            // Calculate pagination
            const totalPages = Math.ceil(sortedData.length / itemsPerPage);
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const paginatedData = sortedData.slice(startIndex, endIndex);

            let html = 
                '<div style="margin-bottom: 15px; color: #6c757d;">' +
                    '<strong>Total Results:</strong> ' + sortedData.length + ' draws' +
                '</div>' +
                '<div class="table-wrapper">' +
                '<table class="results-table">' +
                    '<thead>' +
                        '<tr>' +
                            '<th>Date</th>' +
                            '<th>Game</th>' +
                            '<th>Winning Numbers</th>' +
                            '<th>Jackpot</th>' +
                            '<th>Winners</th>' +
                        '</tr>' +
                    '</thead>' +
                    '<tbody>';

            paginatedData.forEach(result => {
                const numbersHTML = result.numbers.map(num => 
                    '<span class="lotto-ball">' + num + '</span>'
                ).join('');

                html += 
                    '<tr>' +
                        '<td>' + formatDate(result.date) + '</td>' +
                        '<td><strong>' + result.game + '</strong></td>' +
                        '<td><div class="lotto-numbers">' + numbersHTML + '</div></td>' +
                        '<td>₱' + formatNumber(result.jackpot) + '</td>' +
                        '<td>' + result.winners + '</td>' +
                    '</tr>';
            });

            html += 
                    '</tbody>' +
                '</table>' +
                '</div>' +
                '<div class="pagination">' +
                    '<button onclick="changePage(-1)" ' + (currentPage === 1 ? 'disabled' : '') + '>' +
                        '◀ Previous' +
                    '</button>' +
                    '<span class="page-info">' +
                        'Page ' + currentPage + ' of ' + totalPages +
                    '</span>' +
                    '<button onclick="changePage(1)" ' + (currentPage === totalPages ? 'disabled' : '') + '>' +
                        'Next ▶' +
                    '</button>' +
                    '<select onchange="changeItemsPerPage(this.value)">' +
                        '<option value="10" ' + (itemsPerPage === 10 ? 'selected' : '') + '>10 per page</option>' +
                        '<option value="15" ' + (itemsPerPage === 15 ? 'selected' : '') + '>15 per page</option>' +
                        '<option value="25" ' + (itemsPerPage === 25 ? 'selected' : '') + '>25 per page</option>' +
                        '<option value="50" ' + (itemsPerPage === 50 ? 'selected' : '') + '>50 per page</option>' +
                    '</select>' +
                '</div>';

            document.getElementById('recentResults').innerHTML = html;
        }

        function changePage(direction) {
            currentPage += direction;
            updateRecentResults();
        }

        function changeItemsPerPage(value) {
            itemsPerPage = parseInt(value);
            currentPage = 1; // Reset to first page
            updateRecentResults();
        }

        function updateFrequencyAnalysis() {
            if (!filteredData || filteredData.length === 0) {
                document.getElementById('frequencyAnalysis').innerHTML = 
                    '<div class="no-data">No data available for frequency analysis.</div>';
                return;
            }

            const gameFilter = document.getElementById('gameFilter').value;
            
            // Only show frequency for 6-digit games
            if (!gameFilter.startsWith('6/') && gameFilter !== 'all') {
                document.getElementById('frequencyAnalysis').innerHTML = 
                    '<div class="info">Frequency analysis is only available for 6-digit lotto games.</div>';
                return;
            }

            const frequency = {};
            filteredData.forEach(result => {
                if (result.game_type.startsWith('6/')) {
                    result.numbers.forEach(num => {
                        frequency[num] = (frequency[num] || 0) + 1;
                    });
                }
            });

            // Sort by frequency
            const sorted = Object.entries(frequency)
                .sort((a, b) => b[1] - a[1]);

            let html = '<h2>Most Frequently Drawn Numbers</h2>';
            html += '<div class="frequency-chart">';
            
            sorted.forEach(([number, count]) => {
                html += 
                    '<div class="frequency-item">' +
                        '<div class="number">' + number + '</div>' +
                        '<div class="count">' + count + 'x</div>' +
                    '</div>';
            });

            html += '</div>';
            document.getElementById('frequencyAnalysis').innerHTML = html;
        }

        function updateDetailedAnalysis() {
            if (!filteredData || filteredData.length === 0) {
                document.getElementById('detailedAnalysis').innerHTML = 
                    '<div class="no-data">No data available for analysis.</div>';
                return;
            }

            const gameStats = {};
            filteredData.forEach(result => {
                if (!gameStats[result.game_type]) {
                    gameStats[result.game_type] = {
                        name: result.game,
                        draws: 0,
                        totalJackpot: 0,
                        totalWinners: 0,
                        avgJackpot: 0
                    };
                }
                gameStats[result.game_type].draws++;
                gameStats[result.game_type].totalJackpot += result.jackpot;
                gameStats[result.game_type].totalWinners += result.winners;
            });

            // Calculate averages
            Object.keys(gameStats).forEach(key => {
                gameStats[key].avgJackpot = gameStats[key].totalJackpot / gameStats[key].draws;
            });

            let html = '<h2>Game Statistics</h2>';
            html += '<div class="table-wrapper">';
            html += '<table class="results-table"><thead><tr>';
            html += '<th>Game</th><th>Total Draws</th><th>Avg Jackpot</th><th>Total Winners</th>';
            html += '</tr></thead><tbody>';

            Object.values(gameStats).forEach(stat => {
                html += 
                    '<tr>' +
                        '<td><strong>' + stat.name + '</strong></td>' +
                        '<td>' + stat.draws + '</td>' +
                        '<td>₱' + formatNumber(Math.round(stat.avgJackpot)) + '</td>' +
                        '<td>' + stat.totalWinners + '</td>' +
                    '</tr>';
            });

            html += '</tbody></table></div>';

            // Add multiple charts section
            html += '<div style="margin-top: 30px;">';
            html += '<h2>Statistical Analysis & Insights</h2>';
            html += '<div class="charts-grid">';
            
            // Chart 1: Number Frequency Distribution
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Top 15 Most Drawn Numbers</div>';
            html += '<div class="chart-canvas-container"><canvas id="analysisChart1"></canvas></div>';
            html += '<div class="chart-insight" id="insight1"></div>';
            html += '</div>';
            
            // Chart 2: Even vs Odd Analysis
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Even vs Odd Distribution</div>';
            html += '<div class="chart-canvas-container"><canvas id="analysisChart2"></canvas></div>';
            html += '<div class="chart-insight" id="insight2"></div>';
            html += '</div>';
            
            // Chart 3: Number Range Distribution
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Number Range Analysis</div>';
            html += '<div class="chart-canvas-container"><canvas id="analysisChart3"></canvas></div>';
            html += '<div class="chart-insight" id="insight3"></div>';
            html += '</div>';
            
            // Chart 4: Consecutive Numbers Frequency
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Consecutive Numbers Pattern</div>';
            html += '<div class="chart-canvas-container"><canvas id="analysisChart4"></canvas></div>';
            html += '<div class="chart-insight" id="insight4"></div>';
            html += '</div>';
            
            // Chart 5: Sum Range Analysis
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Sum of Winning Numbers</div>';
            html += '<div class="chart-canvas-container"><canvas id="analysisChart5"></canvas></div>';
            html += '<div class="chart-insight" id="insight5"></div>';
            html += '</div>';
            
            // Chart 6: Last Digit Analysis
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Last Digit Frequency</div>';
            html += '<div class="chart-canvas-container"><canvas id="analysisChart6"></canvas></div>';
            html += '<div class="chart-insight" id="insight6"></div>';
            html += '</div>';
            
            // Chart 7: Number Gaps
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Average Gap Between Numbers</div>';
            html += '<div class="chart-canvas-container"><canvas id="analysisChart7"></canvas></div>';
            html += '<div class="chart-insight" id="insight7"></div>';
            html += '</div>';
            
            // Chart 8: Hot vs Cold Numbers
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Hot vs Cold Numbers</div>';
            html += '<div class="chart-canvas-container"><canvas id="analysisChart8"></canvas></div>';
            html += '<div class="chart-insight" id="insight8"></div>';
            html += '</div>';
            
            html += '</div></div>';

            // Add overall insights
            html += 
                '<div class="chart-container" style="margin-top: 30px;">' +
                    '<h3>Prediction Strategy Based on Analysis</h3>' +
                    '<div id="overallInsights"></div>' +
                '</div>';
            document.getElementById('detailedAnalysis').innerHTML = html;
            
            // Create all charts
            createAnalysisCharts();
        }

        function createAnalysisCharts() {
            if (!filteredData || filteredData.length === 0) return;
            
            // Filter only 6-digit games for number analysis
            const sixDigitData = filteredData.filter(d => d.game_type.startsWith('6/'));
            
            if (sixDigitData.length === 0) {
                document.getElementById('overallInsights').innerHTML = 
                    '<p style="color: #6c757d;">Please select a 6-digit lotto game for detailed number analysis.</p>';
                return;
            }

            // Chart 1: Hot Numbers
            createHotNumbersChart(sixDigitData);
            
            // Chart 2: Even vs Odd
            createEvenOddChart(sixDigitData);
            
            // Chart 3: Range Distribution
            createRangeDistributionChart(sixDigitData);
            
            // Chart 4: Consecutive Numbers
            createConsecutiveNumbersChart(sixDigitData);
            
            // Chart 5: Sum Range Analysis
            createSumRangeChart(sixDigitData);
            
            // Chart 6: Last Digit Analysis
            createLastDigitChart(sixDigitData);
            
            // Chart 7: Average Gap
            createAverageGapChart(sixDigitData);
            
            // Chart 8: Hot vs Cold
            createHotColdChart(sixDigitData);
            
            // Generate overall insights
            generateOverallInsights(sixDigitData);
        }

        function createHotNumbersChart(data) {
            const canvas = document.getElementById('analysisChart1');
            if (!canvas) return;

            const frequency = {};
            data.forEach(result => {
                result.numbers.forEach(num => {
                    frequency[num] = (frequency[num] || 0) + 1;
                });
            });

            const sorted = Object.entries(frequency).sort((a, b) => b[1] - a[1]).slice(0, 15);
            
            if (window.chart1) window.chart1.destroy();
            
            const ctx = canvas.getContext('2d');
            window.chart1 = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sorted.map(([num]) => num),
                    datasets: [{
                        label: 'Times Drawn',
                        data: sorted.map(([, count]) => count),
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        borderColor: '#000000',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const percentage = ((context.parsed.y / data.length) * 100).toFixed(1);
                                    return 'Drawn ' + context.parsed.y + ' times (' + percentage + '% of draws)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: {
                                padding: 5
                            },
                            title: { 
                                display: true, 
                                text: 'Frequency',
                                padding: 10
                            }
                        },
                        x: {
                            ticks: {
                                padding: 5
                            },
                            title: { 
                                display: true, 
                                text: 'Number',
                                padding: 10
                            }
                        }
                    }
                }
            });

            const topFive = sorted.slice(0, 5).map(([num]) => num).join(', ');
            const avgFreq = (sorted.reduce((sum, [, count]) => sum + count, 0) / sorted.length).toFixed(1);
            document.getElementById('insight1').innerHTML = 
                '<strong>Analysis:</strong> Numbers <strong>' + topFive + '</strong> are the most frequently drawn. ' +
                'Average frequency of top 15: ' + avgFreq + ' times. ' +
                '<br><strong>Recommendation:</strong> Include 2-3 of these hot numbers in your selection for higher statistical coverage.';
        }

        function createEvenOddChart(data) {
            const canvas = document.getElementById('analysisChart2');
            if (!canvas) return;

            let evenCount = 0, oddCount = 0;
            const drawPatterns = { '6E-0O': 0, '5E-1O': 0, '4E-2O': 0, '3E-3O': 0, '2E-4O': 0, '1E-5O': 0, '0E-6O': 0 };
            
            data.forEach(result => {
                let drawEven = 0, drawOdd = 0;
                result.numbers.forEach(num => {
                    if (num % 2 === 0) { evenCount++; drawEven++; }
                    else { oddCount++; drawOdd++; }
                });
                const pattern = drawEven + 'E-' + drawOdd + 'O';
                drawPatterns[pattern]++;
            });

            const evenPercentage = ((evenCount / (evenCount + oddCount)) * 100).toFixed(1);
            const oddPercentage = ((oddCount / (evenCount + oddCount)) * 100).toFixed(1);

            if (window.chart2) window.chart2.destroy();
            
            const ctx = canvas.getContext('2d');
            window.chart2 = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(drawPatterns),
                    datasets: [{
                        label: 'Number of Draws',
                        data: Object.values(drawPatterns),
                        backgroundColor: ['#000000', '#1a1a1a', '#333333', '#4d4d4d', '#666666', '#808080', '#999999'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const percentage = ((context.parsed.y / data.length) * 100).toFixed(1);
                                    return context.parsed.y + ' draws (' + percentage + '%)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { padding: 5 },
                            title: { 
                                display: true, 
                                text: 'Frequency',
                                padding: 10 
                            }
                        },
                        x: { 
                            ticks: {
                                autoSkip: false,
                                maxRotation: 45,
                                minRotation: 45,
                                padding: 5
                            },
                            title: { 
                                display: true, 
                                text: 'Even-Odd Pattern',
                                padding: 10 
                            }
                        }
                    }
                }
            });

            const mostCommon = Object.entries(drawPatterns).sort((a, b) => b[1] - a[1])[0];
            const mostCommonPct = ((mostCommon[1] / data.length) * 100).toFixed(1);
            document.getElementById('insight2').innerHTML = 
                '<strong>Analysis:</strong> Overall distribution is ' + evenPercentage + '% even vs ' + oddPercentage + '% odd. ' +
                'Most common pattern: <strong>' + mostCommon[0] + '</strong> occurs in ' + mostCommonPct + '% of draws. ' +
                '<br><strong>Recommendation:</strong> Aim for 3 even and 3 odd numbers for balanced selection, matching the most common pattern.';
        }

        function createRangeDistributionChart(data) {
            const canvas = document.getElementById('analysisChart3');
            if (!canvas) return;

            const maxNum = getMaxNumber(data[0].game_type);
            const third = Math.floor(maxNum / 3);
            let low = 0, mid = 0, high = 0;
            const rangePatterns = {};

            data.forEach(result => {
                let drawLow = 0, drawMid = 0, drawHigh = 0;
                result.numbers.forEach(num => {
                    if (num <= third) { low++; drawLow++; }
                    else if (num <= third * 2) { mid++; drawMid++; }
                    else { high++; drawHigh++; }
                });
                const pattern = drawLow + '-' + drawMid + '-' + drawHigh;
                rangePatterns[pattern] = (rangePatterns[pattern] || 0) + 1;
            });

            const total = low + mid + high;
            const lowPct = ((low / total) * 100).toFixed(1);
            const midPct = ((mid / total) * 100).toFixed(1);
            const highPct = ((high / total) * 100).toFixed(1);

            if (window.chart3) window.chart3.destroy();
            
            const ctx = canvas.getContext('2d');
            window.chart3 = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Low (1-' + third + ')', 'Mid (' + (third+1) + '-' + (third*2) + ')', 'High (' + (third*2+1) + '-' + maxNum + ')'],
                    datasets: [{
                        data: [low, mid, high],
                        backgroundColor: ['#000000', '#555555', '#999999'],
                        borderWidth: 2,
                        borderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: 20
                    },
                    plugins: {
                        legend: { 
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + ((context.parsed / total) * 100).toFixed(1) + '%';
                                }
                            }
                        }
                    }
                }
            });

            const topPattern = Object.entries(rangePatterns).sort((a, b) => b[1] - a[1])[0];
            const topPatternPct = ((topPattern[1] / data.length) * 100).toFixed(1);
            document.getElementById('insight3').innerHTML = 
                '<strong>Analysis:</strong> Historical distribution shows Low: ' + lowPct + '%, Mid: ' + midPct + '%, High: ' + highPct + '%. ' +
                'Most common pattern: <strong>' + topPattern[0] + '</strong> (Low-Mid-High) appears in ' + topPatternPct + '% of draws. ' +
                '<br><strong>Recommendation:</strong> Select 2 numbers from each range to match the balanced distribution pattern.';
        }

        function createConsecutiveNumbersChart(data) {
            const canvas = document.getElementById('analysisChart4');
            if (!canvas) return;

            const consecutiveCounts = { '0': 0, '1': 0, '2': 0, '3': 0, '4+': 0 };

            data.forEach(result => {
                const sorted = [...result.numbers].sort((a, b) => a - b);
                let consecutiveCount = 0;
                
                for (let i = 0; i < sorted.length - 1; i++) {
                    if (sorted[i + 1] - sorted[i] === 1) {
                        consecutiveCount++;
                    }
                }
                
                if (consecutiveCount >= 4) consecutiveCounts['4+']++;
                else consecutiveCounts[consecutiveCount]++;
            });

            if (window.chart4) window.chart4.destroy();
            
            const ctx = canvas.getContext('2d');
            window.chart4 = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['No Consecutive', '1 Pair', '2 Pairs', '3 Pairs', '4+ Pairs'],
                    datasets: [{
                        label: 'Frequency',
                        data: Object.values(consecutiveCounts),
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        borderColor: '#000000',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const percentage = ((context.parsed.y / data.length) * 100).toFixed(1);
                                    return context.parsed.y + ' draws (' + percentage + '%)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { padding: 5 },
                            title: { 
                                display: true, 
                                text: 'Number of Draws',
                                padding: 10 
                            }
                        },
                        x: {
                            ticks: { padding: 5 },
                            title: { 
                                display: true, 
                                text: 'Consecutive Pairs',
                                padding: 10 
                            }
                        }
                    }
                }
            });

            const mostCommon = Object.entries(consecutiveCounts).sort((a, b) => b[1] - a[1])[0];
            const mostCommonPct = ((mostCommon[1] / data.length) * 100).toFixed(1);
            document.getElementById('insight4').innerHTML = 
                '<strong>Analysis:</strong> <strong>' + mostCommon[0] + '</strong> consecutive pair(s) is most common, occurring in ' + mostCommonPct + '% of draws. ' +
                'Only ' + ((consecutiveCounts['0'] / data.length) * 100).toFixed(1) + '% of draws have no consecutive numbers. ' +
                '<br><strong>Recommendation:</strong> Including 1-2 consecutive numbers (e.g., 15-16 or 23-24) follows the natural pattern.';
        }

        function createSumRangeChart(data) {
            const canvas = document.getElementById('analysisChart5');
            if (!canvas) return;

            const maxNum = getMaxNumber(data[0].game_type);
            const sums = data.map(result => result.numbers.reduce((a, b) => a + b, 0));
            const minSum = Math.min(...sums);
            const maxSum = Math.max(...sums);
            const avgSum = (sums.reduce((a, b) => a + b, 0) / sums.length).toFixed(0);
            
            const ranges = {};
            const rangeSize = 20;
            for (let i = Math.floor(minSum / rangeSize) * rangeSize; i <= maxSum; i += rangeSize) {
                ranges[i + '-' + (i + rangeSize - 1)] = 0;
            }
            
            sums.forEach(sum => {
                const rangeStart = Math.floor(sum / rangeSize) * rangeSize;
                const key = rangeStart + '-' + (rangeStart + rangeSize - 1);
                if (ranges[key] !== undefined) ranges[key]++;
            });

            if (window.chart5) window.chart5.destroy();
            
            const ctx = canvas.getContext('2d');
            window.chart5 = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Object.keys(ranges),
                    datasets: [{
                        label: 'Frequency',
                        data: Object.values(ranges),
                        borderColor: '#000000',
                        backgroundColor: 'rgba(0, 0, 0, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { padding: 5 },
                            title: { 
                                display: true, 
                                text: 'Frequency',
                                padding: 10 
                            }
                        },
                        x: { 
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                padding: 5
                            },
                            title: { 
                                display: true, 
                                text: 'Sum Range',
                                padding: 10 
                            }
                        }
                    }
                }
            });

            const optimalRange = ((maxNum * 6 * 0.45).toFixed(0)) + '-' + ((maxNum * 6 * 0.55).toFixed(0));
            document.getElementById('insight5').innerHTML = 
                '<strong>Analysis:</strong> Sum of winning numbers ranges from ' + minSum + ' to ' + maxSum + '. ' +
                'Average sum: <strong>' + avgSum + '</strong>. Most sums cluster around the middle range. ' +
                '<br><strong>Recommendation:</strong> Aim for a sum between ' + optimalRange + ' for statistically typical draws. Too low or too high sums are rare.';
        }

        function createLastDigitChart(data) {
            const canvas = document.getElementById('analysisChart6');
            if (!canvas) return;

            const lastDigits = {};
            for (let i = 0; i <= 9; i++) lastDigits[i] = 0;
            
            data.forEach(result => {
                result.numbers.forEach(num => {
                    const lastDigit = num % 10;
                    lastDigits[lastDigit]++;
                });
            });

            if (window.chart6) window.chart6.destroy();
            
            const ctx = canvas.getContext('2d');
            window.chart6 = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(lastDigits),
                    datasets: [{
                        label: 'Frequency',
                        data: Object.values(lastDigits),
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        borderColor: '#000000',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = Object.values(lastDigits).reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed.y / total) * 100).toFixed(1);
                                    return 'Appears ' + context.parsed.y + ' times (' + percentage + '%)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { padding: 5 },
                            title: { 
                                display: true, 
                                text: 'Frequency',
                                padding: 10 
                            }
                        },
                        x: { 
                            ticks: { padding: 5 },
                            title: { 
                                display: true, 
                                text: 'Last Digit (0-9)',
                                padding: 10 
                            }
                        }
                    }
                }
            });

            const sortedDigits = Object.entries(lastDigits).sort((a, b) => b[1] - a[1]);
            const topDigits = sortedDigits.slice(0, 3).map(([digit]) => digit).join(', ');
            const leastDigits = sortedDigits.slice(-3).map(([digit]) => digit).join(', ');
            document.getElementById('insight6').innerHTML = 
                '<strong>Analysis:</strong> Last digits <strong>' + topDigits + '</strong> appear most frequently. ' +
                'Least common: ' + leastDigits + '. This shows certain ending patterns are more prevalent. ' +
                '<br><strong>Recommendation:</strong> Ensure variety in last digits. Avoid picking all numbers ending in same digits (e.g., 11, 21, 31).';
        }

        function createAverageGapChart(data) {
            const canvas = document.getElementById('analysisChart7');
            if (!canvas) return;

            const gaps = [];
            data.forEach(result => {
                const sorted = [...result.numbers].sort((a, b) => a - b);
                for (let i = 0; i < sorted.length - 1; i++) {
                    gaps.push(sorted[i + 1] - sorted[i]);
                }
            });

            const gapCounts = {};
            gaps.forEach(gap => {
                gapCounts[gap] = (gapCounts[gap] || 0) + 1;
            });

            const sortedGaps = Object.entries(gapCounts).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));

            if (window.chart7) window.chart7.destroy();
            
            const ctx = canvas.getContext('2d');
            window.chart7 = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sortedGaps.map(([gap]) => gap),
                    datasets: [{
                        label: 'Frequency',
                        data: sortedGaps.map(([, count]) => count),
                        borderColor: '#000000',
                        backgroundColor: 'rgba(0, 0, 0, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { padding: 5 },
                            title: { 
                                display: true, 
                                text: 'Frequency',
                                padding: 10 
                            }
                        },
                        x: { 
                            ticks: {
                                maxRotation: 0,
                                autoSkipPadding: 10,
                                padding: 5
                            },
                            title: { 
                                display: true, 
                                text: 'Gap Size',
                                padding: 10 
                            }
                        }
                    }
                }
            });

            const avgGap = (gaps.reduce((a, b) => a + b, 0) / gaps.length).toFixed(1);
            const mostCommonGap = sortedGaps.sort((a, b) => b[1] - a[1])[0];
            document.getElementById('insight7').innerHTML = 
                '<strong>Analysis:</strong> Average gap between consecutive numbers is <strong>' + avgGap + '</strong>. ' +
                'Most common gap: <strong>' + mostCommonGap[0] + '</strong> spaces between numbers. ' +
                '<br><strong>Recommendation:</strong> Space your numbers naturally. Avoid clustering (gaps of 1-2 only) or extreme spacing (gaps > 15).';
        }

        function createHotColdChart(data) {
            const canvas = document.getElementById('analysisChart8');
            if (!canvas) return;

            const frequency = {};
            const maxNum = getMaxNumber(data[0].game_type);
            
            // Initialize all numbers
            for (let i = 1; i <= maxNum; i++) {
                frequency[i] = 0;
            }
            
            data.forEach(result => {
                result.numbers.forEach(num => {
                    frequency[num]++;
                });
            });

            const sorted = Object.entries(frequency).sort((a, b) => b[1] - a[1]);
            const hot = sorted.slice(0, 10);
            const cold = sorted.slice(-10).reverse();

            if (window.chart8) window.chart8.destroy();
            
            const ctx = canvas.getContext('2d');
            window.chart8 = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [...hot.map(([num]) => num + ' (H)'), ...cold.map(([num]) => num + ' (C)')],
                    datasets: [{
                        label: 'Frequency',
                        data: [...hot.map(([, count]) => count), ...cold.map(([, count]) => count)],
                        backgroundColor: [...hot.map(() => '#ff0000'), ...cold.map(() => '#0000ff')],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const type = context.label.includes('(H)') ? 'Hot' : 'Cold';
                                    return type + ': ' + context.parsed.y + ' times drawn';
                                }
                            }
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { padding: 5 },
                            title: { 
                                display: true, 
                                text: 'Times Drawn',
                                padding: 10 
                            }
                        },
                        x: { 
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                padding: 5
                            },
                            title: { 
                                display: true, 
                                text: 'Number (H=Hot, C=Cold)',
                                padding: 10 
                            }
                        }
                    }
                }
            });

            const hotNums = hot.slice(0, 5).map(([num]) => num).join(', ');
            const coldNums = cold.slice(0, 5).map(([num]) => num).join(', ');
            document.getElementById('insight8').innerHTML = 
                '<strong>Analysis:</strong> Hot numbers (red): <strong>' + hotNums + '</strong> - frequently drawn. ' +
                'Cold numbers (blue): <strong>' + coldNums + '</strong> - rarely drawn. ' +
                '<br><strong>Recommendation:</strong> Balanced strategy: 3-4 hot numbers + 2-3 cold numbers. Some players prefer all hot, others mix for "due" numbers.';
        }

        function generateOverallInsights(data) {
            const frequency = {};
            let evenCount = 0, oddCount = 0;
            const maxNum = getMaxNumber(data[0].game_type);
            const third = Math.floor(maxNum / 3);
            let low = 0, mid = 0, high = 0;
            const sums = [];
            
            data.forEach(result => {
                let sum = 0;
                result.numbers.forEach(num => {
                    frequency[num] = (frequency[num] || 0) + 1;
                    sum += num;
                    if (num % 2 === 0) evenCount++;
                    else oddCount++;
                    if (num <= third) low++;
                    else if (num <= third * 2) mid++;
                    else high++;
                });
                sums.push(sum);
            });

            const topNumbers = Object.entries(frequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([num]) => num);

            const avgSum = (sums.reduce((a, b) => a + b, 0) / sums.length).toFixed(0);
            const targetSum = ((maxNum * 6 * 0.5).toFixed(0));

            let insights = '';
            insights += '<div style="background: #f8f9fa; padding: 1rem; border-left: 4px solid #000; margin-bottom: 1rem;">';
            insights += '<h4 style="margin-top: 0;">Recommended Number Selection Strategy:</h4>';
            insights += '<ul style="line-height: 1.8;">';
            insights += '<li><strong>Hot Numbers (3-4):</strong> Pick from top 10 most frequent: <strong>' + topNumbers.join(', ') + '</strong></li>';
            insights += '<li><strong>Cold Numbers (2-3):</strong> Include 2-3 less frequent numbers for "due" coverage</li>';
            insights += '<li><strong>Even/Odd Balance:</strong> Aim for 3 even + 3 odd numbers (most common pattern)</li>';
            insights += '<li><strong>Range Distribution:</strong> Select 2 numbers from each range (Low: 1-' + third + ', Mid: ' + (third+1) + '-' + (third*2) + ', High: ' + (third*2+1) + '-' + maxNum + ')</li>';
            insights += '<li><strong>Consecutive Numbers:</strong> Include 1-2 consecutive pairs (e.g., 23-24 or 15-16)</li>';
            insights += '<li><strong>Target Sum:</strong> Aim for total sum around ' + targetSum + ' (±30). Current average: ' + avgSum + '</li>';
            insights += '<li><strong>Last Digit Variety:</strong> Avoid all numbers ending with same digit (spread 0-9)</li>';
            insights += '<li><strong>Number Spacing:</strong> Mix close numbers (gap 1-5) with spread numbers (gap 6-15)</li>';
            insights += '</ul>';
            insights += '</div>';
            insights += '<div style="background: #ffffff; padding: 1rem; border-left: 4px solid #000; margin-bottom: 1rem;">';
            insights += '<h4 style="margin-top: 0;">Common Mistakes to Avoid:</h4>';
            insights += '<ul style="line-height: 1.8;">';
            insights += '<li>All consecutive numbers (1,2,3,4,5,6) - extremely rare</li>';
            insights += '<li>All even or all odd - doesn\'t follow natural distribution</li>';
            insights += '<li>All low or all high numbers - lacks range balance</li>';
            insights += '<li>Numbers with same last digit (11,21,31,41,51,61)</li>';
            insights += '<li>Sum too extreme (<100 or >' + (maxNum*6-50) + ') - statistically unlikely</li>';
            insights += '</ul>';
            insights += '</div>';
            insights += '<div style="background: #f8f9fa; padding: 1rem; border-left: 4px solid #000;">';
            insights += '<h4 style="margin-top: 0;">Pro Tips:</h4>';
            insights += '<ul style="line-height: 1.8;">';
            insights += '<li>Use multiple tickets with different strategies (hot-heavy vs balanced)</li>';
            insights += '<li>Rotate your numbers weekly, don\'t stick to same combination</li>';
            insights += '<li>Check recent 10-20 draws for emerging patterns</li>';
            insights += '<li>Trust statistics but remember: each draw is independent</li>';
            insights += '<li>Set a budget - play for fun, not as investment</li>';
            insights += '</ul>';
            insights += '</div>';

            document.getElementById('overallInsights').innerHTML = insights;
        }

        function createAnalysisChart() {
            const canvas = document.getElementById('analysisChart');
            if (!canvas) return;

            // Sort data by date
            const sortedData = [...filteredData].sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            );

            // Group by game type if multiple games selected
            const gameFilter = document.getElementById('gameFilter').value;
            const datasets = [];

            if (gameFilter === 'all') {
                // Create dataset for each game type
                const gameTypes = [...new Set(sortedData.map(d => d.game_type))];
                const colors = ['#000000', '#333333', '#555555', '#777777', '#999999', '#BBBBBB', '#DDDDDD', '#FF0000'];
                
                gameTypes.forEach((gameType, index) => {
                    const gameData = sortedData.filter(d => d.game_type === gameType);
                    const data = gameData.map(d => ({
                        x: d.date,
                        y: d.jackpot / 1000000 // Convert to millions
                    }));
                    
                    datasets.push({
                        label: gameData[0].game,
                        data: data,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '20',
                        tension: 0.4,
                        fill: false,
                        pointRadius: 2,
                        pointHoverRadius: 5
                    });
                });
            } else {
                // Single game selected
                const data = sortedData.map(d => ({
                    x: d.date,
                    y: d.jackpot / 1000000
                }));
                
                datasets.push({
                    label: sortedData[0].game + ' Jackpot',
                    data: data,
                    borderColor: '#000000',
                    backgroundColor: '#00000020',
                    tension: 0.4,
                    fill: true,
                    pointRadius: 3,
                    pointHoverRadius: 6
                });
            }

            // Destroy existing chart if any
            if (window.analysisChartInstance) {
                window.analysisChartInstance.destroy();
            }

            const ctx = canvas.getContext('2d');
            window.analysisChartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ₱' + context.parsed.y.toFixed(2) + 'M';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Jackpot (Millions ₱)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '₱' + value.toFixed(0) + 'M';
                                }
                            }
                        }
                    }
                }
            });
        }

        function updatePredictionAnalysis() {
            if (!filteredData || filteredData.length === 0) {
                document.getElementById('predictionAnalysis').innerHTML = 
                    '<div class="no-data">No data available for predictions. Please load historical data first.</div>';
                return;
            }

            let html = '<h2>AI-Powered Number Prediction</h2>';
            html += '<div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 25px; border-left: 4px solid #000000;">';
            html += '<p style="color: #495057; margin-bottom: 15px; font-size: 1.05em; line-height: 1.6;">';
            html += '<strong>Statistical Analysis & Machine Learning Algorithms</strong><br>';
            html += 'This system employs advanced statistical methods and machine learning techniques to analyze historical lottery data and identify patterns. ';
            html += 'Our algorithms process thousands of historical draws using multiple computational approaches:';
            html += '</p>';
            html += '<div style="color: #6c757d; font-size: 0.95em; line-height: 1.7;">';
            html += '<strong>Mathematical Foundation:</strong><br>';
            html += '• <strong>Probability Theory:</strong> P(E) = n(E) / n(S) - Calculates likelihood of number occurrences<br>';
            html += '• <strong>Statistical Distribution:</strong> χ² test for uniform distribution verification<br>';
            html += '• <strong>Temporal Analysis:</strong> Time-series decomposition: X(t) = T(t) + S(t) + R(t)<br>';
            html += '• <strong>Markov Chains:</strong> Transition probability matrices P<sub>ij</sub> = P(X<sub>t+1</sub>=j | X<sub>t</sub>=i)<br>';
            html += '• <strong>Neural Networks:</strong> Multi-layer perceptron with sigmoid activation σ(x) = 1/(1+e<sup>-x</sup>)<br><br>';
            html += '<strong>Data Processing:</strong><br>';
            html += 'Analyzes frequency distributions, hot/cold number patterns, sequential correlations, weighted recency scores, ';
            html += 'and stochastic simulations across ' + (filteredData ? filteredData.length : '1000+') + ' historical draws. ';
            html += 'Each model applies different statistical methodologies to generate predictions with calculated confidence intervals.<br><br>';
            html += '<strong>Confidence Metrics:</strong><br>';
            html += 'Predictions include confidence scores (30-75%) based on pattern matching strength, historical accuracy, ';
            html += 'data sufficiency, and statistical significance (p-value < 0.05 threshold).';
            html += '</div>';
            html += '</div>';
            
            // Model selector
            html += '<div class="model-selector">' +
                '<label for="predictionModel">Select Prediction Model:</label>' +
                '<select id="predictionModel" onchange="generatePrediction()">' +
                    '<option value="frequency">Frequency-Based (Simple)</option>' +
                    '<option value="hotcold">Hot & Cold Analysis</option>' +
                    '<option value="pattern">Pattern Recognition</option>' +
                    '<option value="weighted">Weighted Average</option>' +
                    '<option value="markov">Markov Chain</option>' +
                    '<option value="neural">Neural Network Simulation</option>' +
                '</select>' +
                '<button class="generate-btn" onclick="generatePrediction()">Generate Predictions</button>' +
            '</div>';

            html += '<div id="predictionResults"></div>';

            document.getElementById('predictionAnalysis').innerHTML = html;
            
            // Auto-generate first prediction
            setTimeout(() => generatePrediction(), 500);
        }

        function generatePrediction() {
            const model = document.getElementById('predictionModel')?.value || 'frequency';
            const gameFilter = document.getElementById('gameFilter').value;
            
            // Filter for 6-digit games only
            let gameData = filteredData.filter(r => r.game_type.startsWith('6/'));
            
            if (gameFilter !== 'all' && gameFilter.startsWith('6/')) {
                gameData = gameData.filter(r => r.game_type === gameFilter);
            }

            if (gameData.length === 0) {
                document.getElementById('predictionResults').innerHTML = 
                    '<div class="info">Please select a 6-digit lotto game (6/58, 6/55, 6/49, 6/45, or 6/42) for predictions.</div>';
                return;
            }

            const maxNumber = getMaxNumber(gameData[0].game_type);
            let predictions = [];
            let modelDescription = '';
            let confidence = 0;

            switch(model) {
                case 'frequency':
                    predictions = predictByFrequency(gameData, maxNumber);
                    modelDescription = 'Selects the most frequently drawn numbers from historical data.<br><br>' +
                        '<strong>Mathematical Approach:</strong><br>' +
                        '• Frequency: f(n) = Count(n) / N where N = total draws<br>' +
                        '• Probability estimation: P(n) = lim<sub>N→∞</sub> f(n)<br>' +
                        '• Selection criterion: S = {n | f(n) ∈ top 6}<br>' +
                        '• Bayesian update: P(n|data) ∝ P(data|n) · P(n)<br><br>' +
                        '<strong>Theoretical Foundation:</strong><br>' +
                        'Law of Large Numbers: as sample size increases, empirical frequency converges to theoretical probability. ' +
                        'Uses maximum likelihood estimation (MLE) where θ̂ = argmax L(θ|data).<br><br>' +
                        '<strong>Simplified Explanation:</strong><br>' +
                        'This method selects numbers that have appeared most frequently in past draws. ' +
                        'It counts how many times each number has appeared (e.g., number 7, number 23, etc.) ' +
                        'and prioritizes those with the highest occurrence rates.<br><br>' +
                        '<strong>Real-World Analogy:</strong><br>' +
                        'Consider a vendor who sells products daily. After tracking 100 days, Customer A bought 45 times, ' +
                        'Customer B bought 30 times, and Customer C bought 25 times. The vendor would stock extra inventory for ' +
                        'frequent customers (A and B). Similarly, the frequency method selects \"frequent visitor\" numbers.<br><br>' +
                        '<strong>Practical Understanding:</strong><br>' +
                        'Imagine a store owner who notices certain customers buy soft drinks almost daily. ' +
                        'Naturally, they would stock more of those items because frequent purchases indicate higher demand. ' +
                        'The same principle applies here - we select numbers that appear frequently in historical data.<br><br>' +
                        '<strong>Sample Computation:</strong><br>' +
                        'In 1,000 draws:<br>' +
                        '• Number 7 appeared: 185 times → frequency = 185/1000 = 18.5%<br>' +
                        '• Number 23 appeared: 178 times → frequency = 178/1000 = 17.8%<br>' +
                        '• Number 42 appeared: 172 times → frequency = 172/1000 = 17.2%<br>' +
                        'Therefore, top 3 numbers are: 7, 23, 42 (highest frequency rates)';
                    confidence = 65;
                    break;
                case 'hotcold':
                    predictions = predictByHotCold(gameData, maxNumber);
                    modelDescription = 'Combines "hot" (frequently drawn) and "cold" (overdue) numbers.<br><br>' +
                        '<strong>Mathematical Approach:</strong><br>' +
                        '• Hot score: H(n) = Σ<sub>i=1</sub><sup>20</sup> δ(n ∈ Draw<sub>i</sub>)<br>' +
                        '• Cold score: C(n) = T - L(n) where L(n) = last appearance time<br>' +
                        '• Combined metric: M(n) = α·H(n) + β·C(n), α=0.7, β=0.3<br>' +
                        '• Selection: Pick top 4 by H(n), random 2 where C(n) > threshold<br><br>' +
                        '<strong>Theoretical Foundation:</strong><br>' +
                        'Based on Gamblers Fallacy correction: balances recent trends (regression to mean) with overdue numbers (statistical anomaly detection). ' +
                        'Uses weighted scoring: W = ∫<sub>0</sub><sup>T</sup> w(t)·f(n,t)dt where w(t) decays exponentially.<br><br>' +
                        '<strong>Simplified Explanation:</strong><br>' +
                        'This method uses two types of numbers: "HOT" (recently drawn) and "COLD" (not drawn for a long time). ' +
                        'The strategy is to select 4 hot numbers and 2 cold numbers, combining \"trending now\" with \"overdue\" selections.<br><br>' +
                        '<strong>Real-World Analogy:</strong><br>' +
                        'Imagine TV show scheduling: Some hosts appear frequently (hot - trending now), while others haven\'t had shows in a while (cold - overdue). ' +
                        'A producer might prioritize current trending hosts but also give opportunities to established talent who deserve a comeback. ' +
                        'This method uses a balanced approach between current trends and overdue opportunities.<br><br>' +
                        '<strong>Practical Understanding:</strong><br>' +
                        'Think of basketball team selection: You\'d choose players who are "hot" now (scored 30 points last game), ' +
                        'but also give playing time to veterans who haven\'t played recently because they might be "due" to perform well. ' +
                        'It\'s not just about current trends - overdue numbers also get consideration.<br><br>' +
                        '<strong>Sample Computation:</strong><br>' +
                        'Last 20 draws analysis:<br>' +
                        '<em>HOT Numbers (frequently appearing):</em><br>' +
                        '• Number 12: appeared 8 times → hot score = 8<br>' +
                        '• Number 28: appeared 7 times → hot score = 7<br>' +
                        '<em>COLD Numbers (long absence):</em><br>' +
                        '• Number 5: last seen 150 draws ago → cold score = 150<br>' +
                        '• Number 31: last seen 120 draws ago → cold score = 120<br>' +
                        '<em>Combined score:</em> M = (0.7 × hot) + (0.3 × cold/10)';
                    confidence = 60;
                    break;
                case 'pattern':
                    predictions = predictByPattern(gameData, maxNumber);
                    modelDescription = 'Analyzes number sequences and distribution patterns.<br><br>' +
                        '<strong>Mathematical Approach:</strong><br>' +
                        '• Range distribution: D<sub>low</sub> + D<sub>mid</sub> + D<sub>high</sub> = 1<br>' +
                        '• Even/Odd ratio: R<sub>E/O</sub> = (Σ E) / (Σ O) from historical data<br>' +
                        '• Chi-square test: χ² = Σ [(O<sub>i</sub> - E<sub>i</sub>)² / E<sub>i</sub>]<br>' +
                        '• Constraint optimization: min ||D<sub>predicted</sub> - D<sub>historical</sub>||<sub>2</sub><br><br>' +
                        '<strong>Theoretical Foundation:</strong><br>' +
                        'Distributional analysis using statistical moments (mean μ, variance σ²). Enforces pattern matching: ' +
                        'E[X] = Σx·P(X=x) and Var[X] = E[X²] - (E[X])². Maintains historical distribution through KL divergence minimization: ' +
                        'D<sub>KL</sub>(P||Q) = Σ P(x)log(P(x)/Q(x)).<br><br>' +
                        '<strong>Simplified Explanation:</strong><br>' +
                        'This method analyzes patterns in number distribution. For example: Are EVEN numbers more common than ODD? ' +
                        'Are there more small numbers (1-20), medium (21-40), or large (41-58)? The algorithm attempts to replicate historical patterns.<br><br>' +
                        '<strong>Real-World Analogy:</strong><br>' +
                        'Consider a bakery owner who notices most customers buy 3 plain and 3 ube bread - a balanced ratio! ' +
                        'Every morning, she prepares a 50-50 ratio. When new customers arrive, they likely follow the same pattern. ' +
                        'Pattern method follows the \"usual distribution\" observed in historical data.<br><br>' +
                        '<strong>Practical Understanding:</strong><br>' +
                        'Think of fashion trends: When observing what people wore previously, patterns emerge. ' +
                        'Rarely does everyone wear red - usually there\'s variety. Rarely are all people short or all tall - balance is typical. ' +
                        'We select numbers that follow \"normal distribution\" - not all low, not all high, but balanced.<br><br>' +
                        '<strong>Sample Computation:</strong><br>' +
                        'Historical pattern in 100 draws:<br>' +
                        '• Low (1-19): 35% of winning numbers<br>' +
                        '• Mid (20-39): 40% of winning numbers<br>' +
                        '• High (40-58): 25% of winning numbers<br>' +
                        '• Even numbers: 55% | Odd: 45%<br>' +
                        '<em>Therefore in prediction:</em> Select 2 low, 2 mid, 2 high numbers + 3 even, 3 odd (follow the pattern)';
                    confidence = 58;
                    break;
                case 'weighted':
                    predictions = predictByWeighted(gameData, maxNumber);
                    modelDescription = 'Uses weighted scoring based on recency and frequency.<br><br>' +
                        '<strong>Mathematical Approach:</strong><br>' +
                        '• Time decay weight: w(i) = 1/(i+1) or w(i) = e<sup>-λi</sup><br>' +
                        '• Weighted score: S(n) = Σ<sub>i=0</sub><sup>N-1</sup> w(i)·δ(n ∈ Draw<sub>i</sub>)<br>' +
                        '• Normalized score: S\'(n) = S(n) / Σ<sub>all n</sub> S(n)<br>' +
                        '• Ranking: Select argmax<sub>n∈{1..M}</sub><sup>6</sup> S(n)<br><br>' +
                        '<strong>Theoretical Foundation:</strong><br>' +
                        'Exponentially Weighted Moving Average (EWMA): newer data weighted more heavily. ' +
                        'Assumes temporal correlation: P(X<sub>t</sub>|X<sub>t-1</sub>,...,X<sub>0</sub>) ≠ P(X<sub>t</sub>). ' +
                        'Integral form: S(n) = ∫<sub>0</sub><sup>T</sup> e<sup>-λt</sup>·I(n,t)dt where I(n,t) is indicator function.<br><br>' +
                        '<strong>Simplified Explanation:</strong><br>' +
                        'This method has a <em>bias toward recent events</em>. Numbers that appeared <strong>recently</strong> receive higher scores ' +
                        'compared to older draws. It treats recent outcomes as more important than historical data.<br><br>' +
                        '<strong>Real-World Analogy:</strong><br>' +
                        'Consider monitoring stock prices. If yesterday the price was $45, last week $42, and last month $40, ' +
                        'which value best reflects today\'s price? Clearly $45, the most recent data point. Older data becomes less relevant. ' +
                        'Similarly, this method assigns greater weight to recent results than historical ones.<br><br>' +
                        '<strong>Practical Understanding:</strong><br>' +
                        'Like a job application review: Employers examine your entire resume but focus primarily on your LATEST experience ' +
                        'rather than work from 10 years ago. Recent experience is more relevant. Similarly, recent draws receive higher weight in scoring.<br><br>' +
                        '<strong>Sample Computation:</strong><br>' +
                        'Number 15 appeared in:<br>' +
                        '• Latest draw (yesterday): weight = 1.0 × 1 = 1.0 points<br>' +
                        '• 3 draws ago: weight = 1/4 = 0.25 points<br>' +
                        '• 10 draws ago: weight = 1/11 = 0.09 points<br>' +
                        '<em>Total score for #15:</em> 1.0 + 0.25 + 0.09 = 1.34 points<br>' +
                        '(Higher score due to recent appearances)';
                    confidence = 62;
                    break;
                case 'markov':
                    predictions = predictByMarkov(gameData, maxNumber);
                    modelDescription = 'Uses Markov chains to predict based on number transitions.<br><br>' +
                        '<strong>Mathematical Approach:</strong><br>' +
                        '• Transition matrix: P<sub>ij</sub> = P(X<sub>t+1</sub>=j | X<sub>t</sub>=i)<br>' +
                        '• P<sub>ij</sub> = Count(i→j) / Count(i) for all i,j<br>' +
                        '• State prediction: π<sub>t+1</sub> = π<sub>t</sub> · P where π is probability vector<br>' +
                        '• Stationary distribution: πP = π, solved by eigenvalue decomposition<br><br>' +
                        '<strong>Theoretical Foundation:</strong><br>' +
                        'First-order Markov property: P(X<sub>t+1</sub>|X<sub>t</sub>,X<sub>t-1</sub>,...) = P(X<sub>t+1</sub>|X<sub>t</sub>). ' +
                        'Chapman-Kolmogorov equation: P<sup>(n)</sup> = P<sup>n</sup> for n-step transitions. ' +
                        'Convergence: lim<sub>n→∞</sub> P<sup>n</sup> = steady state. Matrix must be stochastic: Σ<sub>j</sub>P<sub>ij</sub> = 1, ∀i.<br><br>' +
                        '<strong>Simplified Explanation:</strong><br>' +
                        'This method focuses on <em>transitions</em> or sequential patterns. If number 7 appears in the current draw, ' +
                        'what typically follows in the next draw based on historical data? Are there connections? This method identifies the ' +
                        'most common successor numbers after specific numbers appear.<br><br>' +
                        '<strong>Real-World Analogy:</strong><br>' +
                        'Weather patterns show that rainy days (state A) typically lead to cloudy days (state B), which then lead to sunny days (state C). ' +
                        'This transition pattern is rain→cloudy→sunny. ' +
                        'Similarly, Markov analysis asks: When #7 appears (state), what typically follows next? Based on historical transitions.<br><br>' +
                        '<strong>Practical Understanding:</strong><br>' +
                        'Like a TV series with continuing episodes. After a cliffhanger in Episode 1, you have an idea what comes next, right? ' +
                        'Because the story has a flow. Similarly, if number 12 appeared today, we examine historical data to see what usually follows ' +
                        'after 12. The most frequent successor becomes our prediction.<br><br>' +
                        '<strong>Sample Computation:</strong><br>' +
                        'After Number 7 appeared (100 times in history):<br>' +
                        '• Number 23 followed: 15 times → probability = 15/100 = 15%<br>' +
                        '• Number 31 followed: 12 times → probability = 12/100 = 12%<br>' +
                        '• Number 8 followed: 11 times → probability = 11/100 = 11%<br>' +
                        '<em>Therefore, if #7 appears today, our next prediction likely includes 23, 31, or 8.</em>';
                    confidence = 55;
                case 'neural':
                    predictions = predictByNeural(gameData, maxNumber);
                    modelDescription = 'Simulates neural network pattern recognition with stochastic elements.<br><br>' +
                        '<strong>Mathematical Approach:</strong><br>' +
                        '• Input normalization: x<sub>i</sub> = f(n<sub>i</sub>) / max(f)<br>' +
                        '• Hidden layer: h<sub>j</sub> = σ(Σ<sub>i</sub> w<sub>ij</sub>x<sub>i</sub> + b<sub>j</sub> + ε)<br>' +
                        '• Activation: σ(z) = 1/(1+e<sup>-z</sup>) (sigmoid) or σ(z) = max(0,z) (ReLU)<br>' +
                        '• Noise injection: ε ~ N(0, σ²) adds randomness<br>' +
                        '• Output: y = argmax<sup>6</sup>(h)<br><br>' +
                        '<strong>Why Output Varies:</strong><br>' +
                        '1. <strong>Stochastic Gradient:</strong> Random noise ε ~ N(0,0.3²) injected each iteration<br>' +
                        '2. <strong>Non-deterministic Initialization:</strong> Random weights cause different convergence paths<br>' +
                        '3. <strong>Dropout Simulation:</strong> Random subset of neurons activated: P(active) = p<br>' +
                        '4. <strong>Monte Carlo sampling:</strong> Multiple forward passes with different random seeds<br><br>' +
                        '<strong>Theoretical Foundation:</strong><br>' +
                        'Universal Approximation Theorem: neural networks can approximate any continuous function f: ℝ<sup>n</sup>→ℝ<sup>m</sup>. ' +
                        'Gradient descent: w<sub>t+1</sub> = w<sub>t</sub> - η∇L(w<sub>t</sub>) where L = loss function. ' +
                        'Backpropagation: ∂L/∂w<sub>ij</sub> = ∂L/∂y · ∂y/∂h · ∂h/∂w using chain rule. ' +
                        'Stochasticity ensures exploration of solution space and prevents overfitting to single pattern.<br><br>' +
                        '<strong>Simplified Explanation:</strong><br>' +
                        'This simulates an <em>artificial brain</em> learning from patterns. However, there\'s a twist - it includes random elements, so ' +
                        '<strong>outputs vary</strong> with each run. Unlike other methods with fixed outputs, this one has a "creativity" element.<br><br>' +
                        '<strong>Real-World Analogy:</strong><br>' +
                        'Consider a student learning mathematics. When asked what 2+2 equals, they answer 4. ' +
                        'But sometimes, depending on various factors (the noise element), they might answer 3.8 or 4.2 - close but not exact. ' +
                        'Neural networks work similarly - they learn from data but include some randomness to avoid being overly predictable.<br><br>' +
                        '<strong>Practical Understanding:</strong><br>' +
                        'Like teaching a child to recognize patterns in pictures. You train them to identify dogs in photos. ' +
                        'Eventually they learn. But with new pictures, they might still make mistakes because they\'re "thinking" based on what they learned. ' +
                        'These small errors mean outputs vary each time. That\'s neural networks - learning but imperfect.<br><br>' +
                        '<strong>Sample Computation:</strong><br>' +
                        'Input: frequency scores for all numbers<br>' +
                        '• Number 7: score = 0.85 + random(0.3) = 1.12<br>' +
                        '• Number 15: score = 0.70 + random(0.3) = 0.85<br>' +
                        '• Number 23: score = 0.90 + random(0.3) = 1.15<br>' +
                        '<em>Output:</em> Top 6 based sa adjusted scores<br>' +
                        '<em>Bakit iba kada run?</em> Yung "+random" part ay nag-change every time! Kaya may variety!';
                    confidence = 53;
                    break;escription = 'Simulates neural network pattern recognition with stochastic elements.<br><br>' +
                        '<strong>Mathematical Approach:</strong><br>' +
                        '• Input normalization: x<sub>i</sub> = f(n<sub>i</sub>) / max(f)<br>' +
                        '• Hidden layer: h<sub>j</sub> = σ(Σ<sub>i</sub> w<sub>ij</sub>x<sub>i</sub> + b<sub>j</sub> + ε)<br>' +
                        '• Activation: σ(z) = 1/(1+e<sup>-z</sup>) (sigmoid) or σ(z) = max(0,z) (ReLU)<br>' +
                        '• Noise injection: ε ~ N(0, σ²) adds randomness<br>' +
                        '• Output: y = argmax<sup>6</sup>(h)<br><br>' +
                        '<strong>Why Output Varies:</strong><br>' +
                        '1. <strong>Stochastic Gradient:</strong> Random noise ε ~ N(0,0.3²) injected each iteration<br>' +
                        '2. <strong>Non-deterministic Initialization:</strong> Random weights cause different convergence paths<br>' +
                        '3. <strong>Dropout Simulation:</strong> Random subset of neurons activated: P(active) = p<br>' +
                        '4. <strong>Monte Carlo sampling:</strong> Multiple forward passes with different random seeds<br><br>' +
                        '<strong>Theoretical Foundation:</strong><br>' +
                        'Universal Approximation Theorem: neural networks can approximate any continuous function f: ℝ<sup>n</sup>→ℝ<sup>m</sup>. ' +
                        'Gradient descent: w<sub>t+1</sub> = w<sub>t</sub> - η∇L(w<sub>t</sub>) where L = loss function. ' +
                        'Backpropagation: ∂L/∂w<sub>ij</sub> = ∂L/∂y · ∂y/∂h · ∂h/∂w using chain rule. ' +
                        'Stochasticity ensures exploration of solution space and prevents overfitting to single pattern.';
                    confidence = 53;
                    break;
            }

            displayPredictions(predictions, model, modelDescription, confidence, gameData[0].game);
        }

        function getMaxNumber(gameType) {
            const match = gameType.match(/\d+$/);
            return match ? parseInt(match[0]) : 58;
        }

        function predictByFrequency(gameData, maxNumber) {
            const frequency = {};
            gameData.forEach(result => {
                result.numbers.forEach(num => {
                    frequency[num] = (frequency[num] || 0) + 1;
                });
            });

            return Object.entries(frequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6)
                .map(([num]) => parseInt(num))
                .sort((a, b) => a - b);
        }

        function predictByHotCold(gameData, maxNumber) {
            const recent = gameData.slice(0, Math.min(20, gameData.length));
            const hotNumbers = {};
            
            recent.forEach(result => {
                result.numbers.forEach(num => {
                    hotNumbers[num] = (hotNumbers[num] || 0) + 1;
                });
            });

            const allNumbers = Array.from({length: maxNumber}, (_, i) => i + 1);
            const coldNumbers = allNumbers.filter(num => !hotNumbers[num] || hotNumbers[num] <= 2);
            
            const hot = Object.entries(hotNumbers)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 4)
                .map(([num]) => parseInt(num));
            
            const cold = coldNumbers
                .sort(() => Math.random() - 0.5)
                .slice(0, 2);
            
            return [...hot, ...cold].sort((a, b) => a - b);
        }

        function predictByPattern(gameData, maxNumber) {
            const ranges = {low: 0, mid: 0, high: 0};
            const evenOdd = {even: 0, odd: 0};
            
            gameData.slice(0, 50).forEach(result => {
                result.numbers.forEach(num => {
                    if (num <= maxNumber / 3) ranges.low++;
                    else if (num <= maxNumber * 2 / 3) ranges.mid++;
                    else ranges.high++;
                    
                    if (num % 2 === 0) evenOdd.even++;
                    else evenOdd.odd++;
                });
            });

            const predictions = [];
            const targetEven = Math.round(6 * evenOdd.even / (evenOdd.even + evenOdd.odd));
            
            const allNumbers = Array.from({length: maxNumber}, (_, i) => i + 1);
            const shuffled = allNumbers.sort(() => Math.random() - 0.5);
            
            let evenCount = 0, oddCount = 0;
            for (let num of shuffled) {
                if (predictions.length >= 6) break;
                if (num % 2 === 0 && evenCount < targetEven) {
                    predictions.push(num);
                    evenCount++;
                } else if (num % 2 !== 0 && oddCount < (6 - targetEven)) {
                    predictions.push(num);
                    oddCount++;
                }
            }
            
            return predictions.sort((a, b) => a - b);
        }

        function predictByWeighted(gameData, maxNumber) {
            const weights = {};
            
            gameData.forEach((result, index) => {
                const recencyWeight = 1 / (index + 1);
                result.numbers.forEach(num => {
                    weights[num] = (weights[num] || 0) + recencyWeight;
                });
            });

            return Object.entries(weights)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6)
                .map(([num]) => parseInt(num))
                .sort((a, b) => a - b);
        }

        function predictByMarkov(gameData, maxNumber) {
            const transitions = {};
            
            for (let i = 0; i < gameData.length - 1; i++) {
                const current = gameData[i].numbers;
                const next = gameData[i + 1].numbers;
                
                current.forEach(num => {
                    if (!transitions[num]) transitions[num] = {};
                    next.forEach(nextNum => {
                        transitions[num][nextNum] = (transitions[num][nextNum] || 0) + 1;
                    });
                });
            }

            const lastDraw = gameData[0].numbers;
            const predictions = new Set();
            
            lastDraw.forEach(num => {
                if (transitions[num]) {
                    const likely = Object.entries(transitions[num])
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 2)
                        .map(([n]) => parseInt(n));
                    likely.forEach(n => predictions.add(n));
                }
            });

            while (predictions.size < 6) {
                predictions.add(Math.floor(Math.random() * maxNumber) + 1);
            }

            return Array.from(predictions).slice(0, 6).sort((a, b) => a - b);
        }

        function predictByNeural(gameData, maxNumber) {
            const inputs = [];
            const recent = gameData.slice(0, Math.min(100, gameData.length));
            
            const numberOccurrences = {};
            recent.forEach(result => {
                result.numbers.forEach(num => {
                    numberOccurrences[num] = (numberOccurrences[num] || 0) + 1;
                });
            });

            const normalized = Object.entries(numberOccurrences).map(([num, count]) => ({
                num: parseInt(num),
                score: count / recent.length + Math.random() * 0.3
            }));

            normalized.sort((a, b) => b.score - a.score);

            return normalized
                .slice(0, 6)
                .map(item => item.num)
                .sort((a, b) => a - b);
        }

        function displayPredictions(predictions, model, description, confidence, gameName) {
            const modelNames = {
                'frequency': 'Frequency-Based Model',
                'hotcold': 'Hot & Cold Analysis',
                'pattern': 'Pattern Recognition Model',
                'weighted': 'Weighted Average Model',
                'markov': 'Markov Chain Model',
                'neural': 'Neural Network Simulation'
            };

            let html = '<div class="prediction-section">';
            html += '<h3>' + modelNames[model] + '</h3>';
            html += '<p style="color: #6c757d; margin-bottom: 10px;">Game: <strong>' + gameName + '</strong></p>';
            
            html += '<div class="prediction-numbers">';
            predictions.forEach(num => {
                html += '<div class="prediction-ball">' + num + '</div>';
            });
            html += '</div>';

            html += '<div class="model-info">';
            html += '<strong>Model Description:</strong> ' + description + '<br><br>';
            html += '<strong>Confidence Level:</strong><br>';
            html += '<div class="confidence-bar">';
            html += '<div class="confidence-fill" style="width: ' + confidence + '%"></div>';
            html += '</div>';
            html += '<span>' + confidence + '% (Based on historical pattern matching)</span><br><br>';
            html += '<strong>Important Notice:</strong> This is a statistical prediction based on historical data. ';
            html += 'Lottery draws are random and past results do not guarantee future outcomes. ';
            html += 'Use these predictions for entertainment purposes only.';
            html += '</div>';

            // Add time series chart for number frequency trends
            html += '<div class="chart-wrapper">';
            html += '<div class="chart-title">Number Frequency Trends Over Time</div>';
            html += '<div class="chart-canvas-container"><canvas id="predictionChart"></canvas></div>';
            html += '<div class="chart-insight" id="predictionInsight">';
            html += '<strong>Analysis:</strong> This chart tracks how often each predicted number has appeared in the last 30 draws over time. ';
            html += 'The rolling window analysis shows whether these numbers are gaining momentum (trending up), losing momentum (trending down), or maintaining steady frequency. ';
            html += '<br><strong>How to Read:</strong> Each black line represents one predicted number. Higher percentages mean the number appeared more frequently in recent draws. ';
            html += 'Rising trends suggest increasing "hotness", while declining trends may indicate the number is cooling off. ';
            html += '<br><strong>Strategic Insight:</strong> Numbers with upward trends are currently "hot" and may continue appearing. Numbers with declining trends might be due for a comeback or entering a "cold" phase. ';
            html += 'A flat line indicates consistent, stable frequency - these are reliable picks for balanced strategies.';
            html += '</div>';
            html += '</div>';

            document.getElementById('predictionResults').innerHTML = html;
            
            // Create prediction trend chart
            createPredictionChart(predictions);
        }

        function createPredictionChart(predictedNumbers) {
            const canvas = document.getElementById('predictionChart');
            if (!canvas) return;

            const gameFilter = document.getElementById('gameFilter').value;
            let gameData = filteredData.filter(r => r.game_type.startsWith('6/'));
            
            if (gameFilter !== 'all' && gameFilter.startsWith('6/')) {
                gameData = gameData.filter(r => r.game_type === gameFilter);
            }

            // Sort by date
            const sortedData = [...gameData].sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            );

            // Track frequency of predicted numbers over time (rolling window)
            const windowSize = 30; // 30 draws rolling window
            const datasets = [];

            predictedNumbers.forEach((num, index) => {
                const frequencyOverTime = [];
                
                for (let i = windowSize; i < sortedData.length; i++) {
                    const window = sortedData.slice(i - windowSize, i);
                    let count = 0;
                    window.forEach(draw => {
                        if (draw.numbers.includes(num)) count++;
                    });
                    
                    frequencyOverTime.push({
                        x: sortedData[i].date,
                        y: (count / windowSize) * 100 // Percentage
                    });
                }

                datasets.push({
                    label: 'Number ' + num,
                    data: frequencyOverTime,
                    borderColor: '#000000',
                    backgroundColor: 'rgba(0, 0, 0, 0.1)',
                    tension: 0.4,
                    fill: false,
                    pointRadius: 1,
                    pointHoverRadius: 4
                });
            });

            // Destroy existing chart if any
            if (window.predictionChartInstance) {
                window.predictionChartInstance.destroy();
            }

            const ctx = canvas.getContext('2d');
            window.predictionChartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                padding: 10,
                                font: {
                                    size: 11
                                },
                                color: '#000000',
                                filter: function(legendItem, chartData) {
                                    // Show all legend items
                                    return true;
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM yyyy'
                                }
                            },
                            ticks: {
                                padding: 5
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                padding: 10
                            }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                padding: 5,
                                callback: function(value) {
                                    return value + '%';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Frequency in Last 30 Draws (%)',
                                padding: 10
                            }
                        }
                    }
                }
            });
        }
        function generateBalanced(gameData, maxNumber) {
            const third = Math.floor(maxNumber / 3);
            const nums = [];
            
            nums.push(Math.floor(Math.random() * third) + 1);
            nums.push(Math.floor(Math.random() * third) + third + 1);
            nums.push(Math.floor(Math.random() * third) + (third * 2) + 1);
            
            while (nums.length < 6) {
                const num = Math.floor(Math.random() * maxNumber) + 1;
                if (!nums.includes(num)) nums.push(num);
            }
            
            return nums.sort((a, b) => a - b);
        }

        function generateRandom(maxNumber) {
            const nums = new Set();
            while (nums.size < 6) {
                nums.add(Math.floor(Math.random() * maxNumber) + 1);
            }
            return Array.from(nums).sort((a, b) => a - b);
        }

        function calculateConfidence(predictions, gameData, maxNumber, method) {
            // Calculate historical frequency of predicted numbers
            const frequency = {};
            gameData.forEach(result => {
                result.numbers.forEach(num => {
                    frequency[num] = (frequency[num] || 0) + 1;
                });
            });

            let baseConfidence = 0;
            let frequencyScore = 0;
            let patternMatch = 0;
            
            // Calculate average frequency of predicted numbers
            predictions.forEach(num => {
                if (frequency[num]) {
                    frequencyScore += frequency[num];
                }
            });
            frequencyScore = (frequencyScore / (gameData.length * 6)) * 100;

            // Calculate pattern matching (how many predicted numbers appeared in recent draws)
            const recent10 = gameData.slice(0, 10);
            const recentNumbers = new Set();
            recent10.forEach(draw => {
                draw.numbers.forEach(num => recentNumbers.add(num));
            });
            predictions.forEach(num => {
                if (recentNumbers.has(num)) patternMatch++;
            });

            // Method-specific confidence calculation
            switch(method) {
                case 'random':
                    // Random has lowest confidence (pure chance)
                    // C = 30 + 0×(any pattern) = 30%
                    baseConfidence = 30;
                    return Math.round(baseConfidence);
                    
                case 'balanced':
                    // Balanced uses distribution matching
                    // C = 45 + (pattern_matches × 3.33) + (frequency_score × 0.1)
                    baseConfidence = 45;
                    const patternBonus = patternMatch * 3.33; // Up to 20% if all 6 match
                    const freqBonus = frequencyScore * 0.1; // Small bonus for frequent numbers
                    return Math.round(Math.min(baseConfidence + patternBonus + freqBonus, 70));
                    
                case 'recent':
                    // Recent trends uses recency weighting
                    // C = 55 + (frequency_score × 0.2) + (pattern_match × 2.5)
                    baseConfidence = 55;
                    const freqWeight = frequencyScore * 0.2;
                    const recentBonus = patternMatch * 2.5; // Up to 15% bonus
                    return Math.round(Math.min(baseConfidence + freqWeight + recentBonus, 75));
                    
                default:
                    return 50;
            }
        }

        function switchTab(event, tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }

        function formatNumber(num) {
            return new Intl.NumberFormat('en-PH').format(num);
        }
    </script>
</body>
</html>
